# Automata-Theory
This repository contains implementations coded as a part of the course Automata Theory in Year 2 Sem 1.

# Question 1 - PFSA-Based Letter-Level Autocomplete
## Overview

This project implements a Probabilistic Finite State Automaton (PFSA) for a letter-level autocomplete system using a given text corpus of valid English words.
The PFSA is constructed from the corpus and stored in a JSON format, then used to generate random words that match the learned probability distribution.

## How It Works
### States:
- Each state represents a prefix of a valid English word from the corpus.
- States that correspond to complete words are marked with a * to distinguish them from prefixes.
- No dead states are included (all states have at least one outgoing transition).

### Transitions:
- Directed edges represent adding the next character to the prefix.
- Transition probabilities are computed from corpus frequencies.
- Outgoing probabilities from a state sum to 1 (probability axiom).

### Initial State:
- Represented by "*".
- Has transitions to single-letter states based on letter frequencies in the corpus.

### End States:
- States corresponding to complete words in the corpus are marked with "*" and considered terminal.

## Random Word Generation

- The program can load the PFSA from JSON and sample words by walking through states according to their transition probabilities.
- Words are generated until an end state is reached (prefix ending in *).
- Sampling is probabilistic, so words appear according to their likelihood in the original corpus.

## Validation
The generated word distribution can be compared with the original corpus distribution to ensure correctness.

# Question 2 - Simple Compiler with Tokenization and CFG Parsing
## Overview
- This project implements a simple compiler for a custom programming language.
- The compiler is capable of:
    - Lexical Analysis (Tokenization) using Finite State Automata (FSA) for each token type.
    - Syntactic Analysis (Parsing) based on a given Context-Free Grammar (CFG).
- The system recognizes multiple token types, applies token hierarchy rules to resolve conflicts, and validates whether the source code adheres to the provided grammar.

## Features
### Tokenization (Lexical Analysis)
- Implemented Finite State Automata for each token type:
    - Identifiers
    - Keywords (if, else)
    - Integers
    - Floating-point numbers
    - Symbols (+, -, *, /, ^, ;, parentheses, etc.)
- Token Hierarchy:
    - If a string matches multiple token patterns, priority is given in this order:
    Keyword > Identifier > Number > Symbol
    - Example: "if" is recognized as a keyword even if it matches the identifier pattern.

### Syntactic Analysis (CFG Parsing)
The compiler checks syntactical correctness on the basis of the following context free grammar:
- Rule 1:         S           -> statement
- Rule 2:         statement   -> if A | (statement)(statement) | y
- Rule 3:         A           -> (condition)(statement) | (condition)(statement)(else)(statement)
- Rule 4:         condition   -> (x)(op1)(x) | (x)
- Rule 5:         op1         -> + | - | * | / | ^ | < | > | =
- Rule 6:         x           -> R(real numbers) | condition | y
- Rule 7:         y            ∈ statement alphabets [Σstatement ]

- Σstatement = numbers U keywords U identifiers - {’if ’ , ’else’}

Note: The grammar above needs to be strictly followed (including the brackets) for the code to be accepted by the compiler. 
For example:
if (x>0)(print x) - Syntax Error
Correct syntax - if ((x)(>)(0))(print x)    [according to Rule 2 and 7]

### Parsing Workflow
- Token Stream Input – Generated by lexical analysis.
- Recursive Descent Parsing – Implements grammar rules as functions for parsing specific constructs.
- Error Handling – Reports syntax errors with clear messages and positions.